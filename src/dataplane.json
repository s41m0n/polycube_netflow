{
    "ingress-path": {
        "name": "Packets feature extractor",
        "code": "/*Protocol types according to the standard*/\n#define ETH_P_IP        0x0800 \n#define ETH_P_IPV6      0x86DD\n#define IPPROTO_ICMP    1\n#define IPPROTO_ICMPV6  58\n#define IPPROTO_TCP     6\n#define IPPROTO_UDP     17\n\n#define FLOW_MAP_SIZE   100\n\nenum CONNECTION_STATE {\n    UP, SENT_CLOSE_FROM_ME, SENT_CLOSE_FROM_PARTNER, CLOSED\n};\n\n/*Ethernet Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/if_ether.h (slightly different)*/\nstruct eth_hdr {\n    __be64 dst: 48;\n    __be64 src: 48;\n    __be16 proto;\n} __attribute__((packed));\n\n/*IPv4 Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/ip.h */\nstruct iphdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u8    ihl:4,\n        version:4;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n    __u8    version:4,\n        ihl:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n    __u8 tos;\n    __be16 tot_len;\n    __be16 id;\n    __be16 frag_off;\n    __u8 ttl;\n    __u8 protocol;\n    __sum16 check;\n    __be32 saddr;\n    __be32 daddr;\n    /*The options start here. */\n} __attribute__((packed));\n\n/*IPv6 Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/ipv6.h*/\nstruct ipv6hdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n  __u8      tc1:4,\n        version:4;\n  __u8      flow_lbl1:4,\n        tc2:4;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n  __u8      version:4,\n        tc1:4;\n  __u8      tc2:4,\n        flow_lbl1:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n  __u8      flow_lbl2[2];\n\n  __be16      payload_len;\n  __u8      nexthdr;\n  __u8      hop_limit;\n\n  __u64    saddr[2];\n  __u64    daddr[2];\n};\n\n/*TCP Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/tcp.h */\nstruct tcphdr {\n    __be16 source;\n    __be16 dest;\n    __be32 seq;\n    __be32 ack_seq;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u16   res1:4,\n        doff:4,\n        fin:1,\n        syn:1,\n        rst:1,\n        psh:1,\n        ack:1,\n        urg:1,\n        ece:1,\n        cwr:1;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n    __u16   doff:4,\n        res1:4,\n        cwr:1,\n        ece:1,\n        urg:1,\n        ack:1,\n        psh:1,\n        rst:1,\n        syn:1,\n        fin:1;\n#else\n#error  \"Adjust your <asm/byteorder.h> defines\"\n#endif\n    __be16 window;\n    __sum16 check;\n    __be16 urg_ptr;\n} __attribute__((packed));\n\n/*UDP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/udp.h */\nstruct udphdr {\n    __be16 source;\n    __be16 dest;\n    __be16 len;\n    __sum16 check;\n} __attribute__((packed));\n\n/*ICMP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/icmp.h*/\nstruct icmphdr {\n    __u8 type;\n    __u8 code;\n    __sum16 checksum;\n    union {\n        struct {\n            __be16 id;\n            __be16 sequence;\n        } echo;\n        __be32 gateway;\n        struct {\n            __be16 __unused;\n            __be16 mtu;\n        } frag;\n        __u8 reserved[4];\n    } un;\n} __attribute__((packed));\n\n/*Features to be exported*/\nstruct features {\n    //Real features\n    uint64_t packets;                    // Number of packets\n    uint64_t bytes;                      // Number of bytes\n    uint64_t flows;                      // Number of flows (if FYN then restarted)\n    uint8_t flags;                       // Flags if any\n    uint8_t  tos;                        // ToS value\n    uint64_t start_timestamp;            // Connection begin timestamp\n    uint64_t alive_timestamp;            // Last message received timestamp\n    uint8_t status;                      // To track reset & reuse\n} __attribute__((packed));\n\n/*Flow identifier IPv4*/\nstruct flow_identifier_v4 {\n    __be32 saddr;                        //IP source address\n    __be32 daddr;                        //IP dest address\n    __be16 sport;                        //Source port\n    __be16 dport;                        //Dest port\n    __u8   proto;                        //Protocol ID\n} __attribute__((packed));\n\n/*Flow identifier IPv6*/\nstruct flow_identifier_v6 {\n    __u64  saddr[2];                     //IP source address\n    __u64  daddr[2];                     //IP dest address\n    __be16 sport;                        //Source port\n    __be16 dport;                        //Dest port\n    __u8   proto;                        //Protocol ID\n} __attribute__((packed));\n\n\n/*Flow map IPv4*/\nBPF_TABLE_SHARED(\"lru_hash\", struct flow_identifier_v4, struct features, FLOW_MAP_V4, FLOW_MAP_SIZE);\n\n/*Flow map IPv6*/\nBPF_TABLE_SHARED(\"lru_hash\", struct flow_identifier_v6, struct features, FLOW_MAP_V6, FLOW_MAP_SIZE);\n\nstatic __always_inline void push_ipv4(struct flow_identifier_v4 *key, uint16_t len, uint8_t tos) {\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct features *value = FLOW_MAP_V4.lookup(key);\n  if(!value) {\n    struct features new = {.packets=1, .bytes=len, .flows=1, .tos=tos, .start_timestamp=curr_time, .alive_timestamp=curr_time, .status=0, .flags=0};\n    FLOW_MAP_V4.insert(key, &new);\n  } else {\n    value->packets++;\n    value->bytes += len;\n    value->alive_timestamp = curr_time;\n  }\n}\n\nstatic __always_inline void push_ipv6(struct flow_identifier_v6 *key, uint16_t len, uint8_t tos) {\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct features *value = FLOW_MAP_V6.lookup(key);\n  if(!value) {\n    struct features new = {.packets=1, .bytes=len, .flows=1, .tos=tos, .start_timestamp=curr_time, .alive_timestamp=curr_time, .status=0, .flags=0};\n    FLOW_MAP_V6.insert(key, &new);\n  } else {\n    value->packets++;\n    value->bytes += len;\n    value->alive_timestamp = curr_time;\n  }\n}\n\nstatic __always_inline void push_tcp_ipv4(struct tcphdr *tcp, struct flow_identifier_v4 *key, uint16_t len, uint8_t tos) {\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct features *value = FLOW_MAP_V4.lookup(key);\n  if(!value) {\n    struct features new = {.packets=1, .bytes=len, .flows=1, .tos=tos, .start_timestamp=curr_time, .alive_timestamp=curr_time, .flags=(tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4)\n                | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin, .status=0};\n    FLOW_MAP_V4.insert(key, &new);\n  } else {\n    value->packets++;\n    value->bytes += len;\n    value->alive_timestamp = curr_time;\n    value->flags |= (tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4) | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin;\n    /*INGRESS*/\n    if(tcp->syn && value->status == CLOSED) {\n        value->flows++;\n        value->status = UP;\n    } else if (tcp->fin) {\n      if(value->status==SENT_CLOSE_FROM_ME)\n        value->status = CLOSED;\n      else\n        value->status = SENT_CLOSE_FROM_PARTNER;\n    } else if(tcp->rst) {\n      value->status = CLOSED;\n    }\n  }\n}\n\nstatic __always_inline void push_tcp_ipv6(struct tcphdr *tcp, struct flow_identifier_v6 *key, uint16_t len, uint8_t tos) {\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct features *value = FLOW_MAP_V6.lookup(key);\n  if(!value) {\n    struct features new = {.packets=1, .bytes=len, .flows=1, .tos=tos, .start_timestamp=curr_time, .alive_timestamp=curr_time, .flags=(tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4)\n                | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin, .status=0};\n    FLOW_MAP_V6.insert(key, &new);\n  } else {\n    value->packets++;\n    value->bytes += len;\n    value->alive_timestamp = curr_time;\n    value->flags |= (tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4) | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin;\n    /*INGRESS*/\n    if(tcp->syn && value->status == CLOSED) {\n        value->flows++;\n        value->status = UP;\n    } else if (tcp->fin) {\n      if(value->status==SENT_CLOSE_FROM_ME)\n        value->status = CLOSED;\n      else\n        value->status = SENT_CLOSE_FROM_PARTNER;\n    } else if(tcp->rst) {\n      value->status = CLOSED;\n    }\n  }\n}\n\nstatic __always_inline int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n  void *data = (void *) (long) ctx->data;\n  void *data_end = (void *) (long) ctx->data_end;\n\n  /*Parsing L2*/\n  struct eth_hdr *ethernet = data;\n  if (data + sizeof(*ethernet) > data_end)\n    return RX_OK;\n\n  if (ethernet->proto == bpf_htons(ETH_P_IP)) {\n    /*Parsing L3*/\n    struct iphdr *ip = data + sizeof(struct eth_hdr);\n    if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n      return RX_OK;\n    \n    if ((int) ip->version != 4)\n      return RX_OK;\n    \n    uint8_t ip_header_len = ip->ihl << 2;\n    switch (ip->protocol) {\n    case IPPROTO_TCP: {\n      //Parsing L4 TCP\n      struct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) tcp + sizeof(*tcp) > data_end)\n        return RX_OK;\n\n      struct flow_identifier_v4 key = {.saddr=ip->saddr, .daddr=ip->daddr, .sport=tcp->source, .dport=tcp->dest, .proto=ip->protocol};\n      push_tcp_ipv4(tcp, &key, bpf_ntohs(ip->tot_len), ip->tos);\n      break;\n    }\n    case IPPROTO_UDP: {\n      //Parsing L4 UDP\n      struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) udp + sizeof(*udp) > data_end) {\n        return RX_OK;\n      }\n      \n      struct flow_identifier_v4 key = {.saddr=ip->saddr, .daddr=ip->daddr,.sport=udp->source, .dport=udp->dest, .proto=ip->protocol};\n      push_ipv4(&key, bpf_ntohs(ip->tot_len), ip->tos);\n      break;\n    }\n    case IPPROTO_ICMP: {\n      /*Parsing L4 ICMP*/\n      struct icmphdr *icmp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) icmp + sizeof(*icmp) > data_end) {\n        return RX_OK;\n      }\n\n      struct flow_identifier_v4 key = {.saddr=ip->saddr, .daddr=ip->daddr, .sport=0, .dport=0, .proto=ip->protocol};\n      push_ipv4(&key, bpf_ntohs(ip->tot_len), ip->tos);\n      break;\n    }\n    /*Ignored protocol*/\n    default : {\n      pcn_log(ctx, LOG_DEBUG, \"IPv4 Untreated protocol\");\n      break;\n    }\n    }\n  } else if (ethernet->proto == bpf_htons(ETH_P_IPV6)) {\n    /*IPv6*/\n    struct ipv6hdr *ip = data + sizeof(struct eth_hdr);\n    \n    if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n      return RX_OK;\n    \n    if ((int) ip->version != 6)\n      return RX_OK;\n    \n    switch(ip->nexthdr) {\n      case IPPROTO_TCP : {\n        //Parsing L4 TCP\n        struct tcphdr *tcp = data + sizeof(struct eth_hdr) + sizeof(struct ipv6hdr);\n        if ((void *) tcp + sizeof(*tcp) > data_end)\n          return RX_OK;\n\n        struct flow_identifier_v6 key = {.sport=tcp->source, .dport=tcp->dest, .proto=ip->nexthdr};\n        key.saddr[0] = ip->saddr[0]; key.saddr[1] = ip->saddr[1];\n        key.daddr[0] = ip->daddr[0]; key.daddr[1] = ip->daddr[1];\n        push_tcp_ipv6(tcp, &key, bpf_ntohs(ip->payload_len), (ip->tc1 << 4) | (ip->tc2));\n        break;\n      }\n      case IPPROTO_UDP : {\n        //Parsing L4 UDP\n        struct udphdr *udp = data + sizeof(struct eth_hdr) + sizeof(struct ipv6hdr);\n        if ((void *) udp + sizeof(*udp) > data_end) {\n          return RX_OK;\n        }\n        \n        struct flow_identifier_v6 key = {.sport=udp->source, .dport=udp->dest, .proto=ip->nexthdr};\n        key.saddr[0] = ip->saddr[0]; key.saddr[1] = ip->saddr[1];\n        key.daddr[0] = ip->daddr[0]; key.daddr[1] = ip->daddr[1];\n        push_ipv6(&key, bpf_ntohs(ip->payload_len), (ip->tc1 << 4) | (ip->tc2));\n        break;\n      }\n      case IPPROTO_ICMPV6 : {\n        /*Parsing L4 ICMP*/\n        struct icmphdr *icmp = data + sizeof(struct eth_hdr) + sizeof(struct ipv6hdr);\n        if ((void *) icmp + sizeof(*icmp) > data_end) {\n          return RX_OK;\n        }\n\n        struct flow_identifier_v6 key = {.sport=0, .dport=0, .proto=ip->nexthdr};\n        key.saddr[0] = ip->saddr[0]; key.saddr[1] = ip->saddr[1];\n        key.daddr[0] = ip->daddr[0]; key.daddr[1] = ip->daddr[1];\n        push_ipv6(&key, bpf_ntohs(ip->payload_len), (ip->tc1 << 4) | (ip->tc2));\n        break;\n      }\n      default: {\n        pcn_log(ctx, LOG_DEBUG, \"IPv6 Untreated protocol\");\n        break;\n      }\n    }\n  } else {\n    pcn_log(ctx, LOG_DEBUG, \"Not an IP Protocol\");\n  }\n\n  /* Here operations after the capture */\n  return RX_OK;\n}",
        "metric-configs": [
            {
                "name": "FLOW_MAP_V4",
                "map-name": "FLOW_MAP_V4",
                "extraction-options": {
                    "swap-on-read": true,
                    "empty-on-read": true
                }
            },
            {
                "name": "FLOW_MAP_V6",
                "map-name": "FLOW_MAP_V6",
                "extraction-options": {
                    "swap-on-read": true,
                    "empty-on-read": true
                }
            }
        ]
    },
    "egress-path": {
        "name": "Packets feature extractor",
        "code": "/*Protocol types according to the standard*/\n#define ETH_P_IP        0x0800 \n#define ETH_P_IPV6      0x86DD\n#define IPPROTO_ICMP    1\n#define IPPROTO_ICMPV6  58\n#define IPPROTO_TCP     6\n#define IPPROTO_UDP     17\n\n#define FLOW_MAP_SIZE   100\n\nenum CONNECTION_STATE {\n    UP, SENT_CLOSE_FROM_ME, SENT_CLOSE_FROM_PARTNER, CLOSED\n};\n\n/*Ethernet Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/if_ether.h (slightly different)*/\nstruct eth_hdr {\n    __be64 dst: 48;\n    __be64 src: 48;\n    __be16 proto;\n} __attribute__((packed));\n\n/*IPv4 Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/ip.h */\nstruct iphdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u8    ihl:4,\n        version:4;\n#elif defined (__BIG_ENDIAN_BITFIELD)\n    __u8    version:4,\n        ihl:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n    __u8 tos;\n    __be16 tot_len;\n    __be16 id;\n    __be16 frag_off;\n    __u8 ttl;\n    __u8 protocol;\n    __sum16 check;\n    __be32 saddr;\n    __be32 daddr;\n    /*The options start here. */\n} __attribute__((packed));\n\n/*IPv6 Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/ipv6.h*/\nstruct ipv6hdr {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n  __u8      tc1:4,\n        version:4;\n  __u8      flow_lbl1:4,\n        tc2:4;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n  __u8      version:4,\n        tc1:4;\n  __u8      tc2:4,\n        flow_lbl1:4;\n#else\n#error  \"Please fix <asm/byteorder.h>\"\n#endif\n  __u8      flow_lbl2[2];\n\n  __be16      payload_len;\n  __u8      nexthdr;\n  __u8      hop_limit;\n\n  __u64    saddr[2];\n  __u64    daddr[2];\n};\n\n/*TCP Header => https://github.com/torvalds/linux/blob/master/include/uapi/linux/tcp.h */\nstruct tcphdr {\n    __be16 source;\n    __be16 dest;\n    __be32 seq;\n    __be32 ack_seq;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n    __u16   res1:4,\n        doff:4,\n        fin:1,\n        syn:1,\n        rst:1,\n        psh:1,\n        ack:1,\n        urg:1,\n        ece:1,\n        cwr:1;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n    __u16   doff:4,\n        res1:4,\n        cwr:1,\n        ece:1,\n        urg:1,\n        ack:1,\n        psh:1,\n        rst:1,\n        syn:1,\n        fin:1;\n#else\n#error  \"Adjust your <asm/byteorder.h> defines\"\n#endif\n    __be16 window;\n    __sum16 check;\n    __be16 urg_ptr;\n} __attribute__((packed));\n\n/*UDP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/udp.h */\nstruct udphdr {\n    __be16 source;\n    __be16 dest;\n    __be16 len;\n    __sum16 check;\n} __attribute__((packed));\n\n/*ICMP Header https://github.com/torvalds/linux/blob/master/include/uapi/linux/icmp.h*/\nstruct icmphdr {\n    __u8 type;\n    __u8 code;\n    __sum16 checksum;\n    union {\n        struct {\n            __be16 id;\n            __be16 sequence;\n        } echo;\n        __be32 gateway;\n        struct {\n            __be16 __unused;\n            __be16 mtu;\n        } frag;\n        __u8 reserved[4];\n    } un;\n} __attribute__((packed));\n\n/*Features to be exported*/\nstruct features {\n    //Real features\n    uint64_t packets;                    // Number of packets\n    uint64_t bytes;                      // Number of bytes\n    uint64_t flows;                      // Number of flows (if FYN then restarted)\n    uint8_t flags;                       // Flags if any\n    uint8_t  tos;                        // ToS value\n    uint64_t start_timestamp;            // Connection begin timestamp\n    uint64_t alive_timestamp;            // Last message received timestamp\n    uint8_t status;                      // To track reset & reuse\n} __attribute__((packed));\n\n/*Flow identifier IPv4*/\nstruct flow_identifier_v4 {\n    __be32 saddr;                        //IP source address\n    __be32 daddr;                        //IP dest address\n    __be16 sport;                        //Source port\n    __be16 dport;                        //Dest port\n    __u8   proto;                        //Protocol ID\n} __attribute__((packed));\n\n/*Flow identifier IPv6*/\nstruct flow_identifier_v6 {\n    __u64  saddr[2];                     //IP source address\n    __u64  daddr[2];                     //IP dest address\n    __be16 sport;                        //Source port\n    __be16 dport;                        //Dest port\n    __u8   proto;                        //Protocol ID\n} __attribute__((packed));\n\n\n/*Flow map IPv4*/\nBPF_TABLE(\"extern\", struct flow_identifier_v4, struct features, FLOW_MAP_V4, FLOW_MAP_SIZE);\n\n/*Flow map IPv6*/\nBPF_TABLE(\"extern\", struct flow_identifier_v6, struct features, FLOW_MAP_V6, FLOW_MAP_SIZE);\n\nstatic __always_inline void push_ipv4(struct flow_identifier_v4 *key, uint16_t len, uint8_t tos) {\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct features *value = FLOW_MAP_V4.lookup(key);\n  if(!value) {\n    struct features new = {.packets=1, .bytes=len, .flows=1, .tos=tos, .start_timestamp=curr_time, .alive_timestamp=curr_time, .status=0, .flags=0};\n    FLOW_MAP_V4.insert(key, &new);\n  } else {\n    value->packets++;\n    value->bytes += len;\n    value->alive_timestamp = curr_time;\n  }\n}\n\nstatic __always_inline void push_ipv6(struct flow_identifier_v6 *key, uint16_t len, uint8_t tos) {\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct features *value = FLOW_MAP_V6.lookup(key);\n  if(!value) {\n    struct features new = {.packets=1, .bytes=len, .flows=1, .tos=tos, .start_timestamp=curr_time, .alive_timestamp=curr_time, .status=0, .flags=0};\n    FLOW_MAP_V6.insert(key, &new);\n  } else {\n    value->packets++;\n    value->bytes += len;\n    value->alive_timestamp = curr_time;\n  }\n}\n\nstatic __always_inline void push_tcp_ipv4(struct tcphdr *tcp, struct flow_identifier_v4 *key, uint16_t len, uint8_t tos) {\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct features *value = FLOW_MAP_V4.lookup(key);\n  if(!value) {\n    struct features new = {.packets=1, .bytes=len, .flows=1, .tos=tos, .start_timestamp=curr_time, .alive_timestamp=curr_time, .flags=(tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4)\n                | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin, .status=0};\n    FLOW_MAP_V4.insert(key, &new);\n  } else {\n    value->packets++;\n    value->bytes += len;\n    value->alive_timestamp = curr_time;\n    value->flags |= (tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4) | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin;\n    /*EGRESS*/\n    if(tcp->syn && value->status == CLOSED) {\n        value->flows++;\n        value->status = UP;\n    } else if(tcp->fin) {\n      if(value->status==SENT_CLOSE_FROM_PARTNER)\n        value->status = CLOSED;\n      else\n        value->status = SENT_CLOSE_FROM_ME;\n    } else if(tcp->rst) {\n      value->status = CLOSED;\n    }\n  }\n}\n\nstatic __always_inline void push_tcp_ipv6(struct tcphdr *tcp, struct flow_identifier_v6 *key, uint16_t len, uint8_t tos) {\n  uint64_t curr_time = pcn_get_time_epoch();\n  struct features *value = FLOW_MAP_V6.lookup(key);\n  if(!value) {\n    struct features new = {.packets=1, .bytes=len, .flows=1, .tos=tos, .start_timestamp=curr_time, .alive_timestamp=curr_time, .flags=(tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4)\n                | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin, .status=0};\n    FLOW_MAP_V6.insert(key, &new);\n  } else {\n    value->packets++;\n    value->bytes += len;\n    value->alive_timestamp = curr_time;\n    value->flags |= (tcp->cwr << 7) | (tcp->ece << 6) | (tcp->urg << 5) | (tcp->ack << 4) | (tcp->psh << 3)| (tcp->rst << 2) | (tcp->syn << 1) | tcp->fin;\n    /*INGRESS*/\n    if(tcp->syn && value->status == CLOSED) {\n        value->flows++;\n        value->status = UP;\n    } else if(tcp->fin) {\n      if(value->status==SENT_CLOSE_FROM_PARTNER)\n        value->status = CLOSED;\n      else\n        value->status = SENT_CLOSE_FROM_ME;\n    } else if(tcp->rst) {\n      value->status = CLOSED;\n    }\n  }\n}\n\nstatic __always_inline int handle_rx(struct CTXTYPE *ctx, struct pkt_metadata *md) {\n  void *data = (void *) (long) ctx->data;\n  void *data_end = (void *) (long) ctx->data_end;\n\n  /*Parsing L2*/\n  struct eth_hdr *ethernet = data;\n  if (data + sizeof(*ethernet) > data_end)\n    return RX_OK;\n\n  if (ethernet->proto == bpf_htons(ETH_P_IP)) {\n    /*Parsing L3*/\n    struct iphdr *ip = data + sizeof(struct eth_hdr);\n    if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n      return RX_OK;\n    \n    if ((int) ip->version != 4)\n      return RX_OK;\n    \n    uint8_t ip_header_len = ip->ihl << 2;\n    switch (ip->protocol) {\n    case IPPROTO_TCP: {\n      //Parsing L4 TCP\n      struct tcphdr *tcp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) tcp + sizeof(*tcp) > data_end)\n        return RX_OK;\n\n      struct flow_identifier_v4 key = {.saddr=ip->daddr, .daddr=ip->saddr, .sport=tcp->dest, .dport=tcp->source, .proto=ip->protocol};\n      push_tcp_ipv4(tcp, &key, bpf_ntohs(ip->tot_len), ip->tos);\n      break;\n    }\n    case IPPROTO_UDP: {\n      //Parsing L4 UDP\n      struct udphdr *udp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) udp + sizeof(*udp) > data_end) {\n        return RX_OK;\n      }\n      \n      struct flow_identifier_v4 key = {.saddr=ip->daddr, .daddr=ip->saddr,.sport=udp->dest, .dport=udp->source, .proto=ip->protocol};\n      push_ipv4(&key, bpf_ntohs(ip->tot_len), ip->tos);\n      break;\n    }\n    case IPPROTO_ICMP: {\n      /*Parsing L4 ICMP*/\n      struct icmphdr *icmp = data + sizeof(struct eth_hdr) + ip_header_len;\n      if ((void *) icmp + sizeof(*icmp) > data_end) {\n        return RX_OK;\n      }\n\n      struct flow_identifier_v4 key = {.saddr=ip->daddr, .daddr=ip->saddr, .sport=0, .dport=0, .proto=ip->protocol};\n      push_ipv4(&key, bpf_ntohs(ip->tot_len), ip->tos);\n      break;\n    }\n    /*Ignored protocol*/\n    default : {\n      pcn_log(ctx, LOG_DEBUG, \"IPv4 Untreated protocol\");\n      break;\n    }\n    }\n  } else if (ethernet->proto == bpf_htons(ETH_P_IPV6)) {\n    /*IPv6*/\n    struct ipv6hdr *ip = data + sizeof(struct eth_hdr);\n    \n    if (data + sizeof(struct eth_hdr) + sizeof(*ip) > data_end)\n      return RX_OK;\n    \n    if ((int) ip->version != 6)\n      return RX_OK;\n    \n    switch(ip->nexthdr) {\n      case IPPROTO_TCP : {\n        //Parsing L4 TCP\n        struct tcphdr *tcp = data + sizeof(struct eth_hdr) + sizeof(struct ipv6hdr);\n        if ((void *) tcp + sizeof(*tcp) > data_end)\n          return RX_OK;\n\n        struct flow_identifier_v6 key = {.sport=tcp->dest, .dport=tcp->source, .proto=ip->nexthdr};\n        key.saddr[0] = ip->daddr[0]; key.saddr[1] = ip->daddr[1];\n        key.daddr[0] = ip->saddr[0]; key.daddr[1] = ip->saddr[1];\n        push_tcp_ipv6(tcp, &key, bpf_ntohs(ip->payload_len), (ip->tc1 << 4) | (ip->tc2));\n        break;\n      }\n      case IPPROTO_UDP : {\n        //Parsing L4 UDP\n        struct udphdr *udp = data + sizeof(struct eth_hdr) + sizeof(struct ipv6hdr);\n        if ((void *) udp + sizeof(*udp) > data_end) {\n          return RX_OK;\n        }\n        \n        struct flow_identifier_v6 key = {.sport=udp->dest, .dport=udp->source, .proto=ip->nexthdr};\n        key.saddr[0] = ip->daddr[0]; key.saddr[1] = ip->daddr[1];\n        key.daddr[0] = ip->saddr[0]; key.daddr[1] = ip->saddr[1];\n        push_ipv6(&key, bpf_ntohs(ip->payload_len), (ip->tc1 << 4) | (ip->tc2));\n        break;\n      }\n      case IPPROTO_ICMPV6 : {\n        /*Parsing L4 ICMP*/\n        struct icmphdr *icmp = data + sizeof(struct eth_hdr) + sizeof(struct ipv6hdr);\n        if ((void *) icmp + sizeof(*icmp) > data_end) {\n          return RX_OK;\n        }\n\n        struct flow_identifier_v6 key = {.sport=0, .dport=0, .proto=ip->nexthdr};\n        key.saddr[0] = ip->daddr[0]; key.saddr[1] = ip->daddr[1];\n        key.daddr[0] = ip->saddr[0]; key.daddr[1] = ip->saddr[1];\n        push_ipv6(&key, bpf_ntohs(ip->payload_len), (ip->tc1 << 4) | (ip->tc2));\n        break;\n      }\n      default: {\n        pcn_log(ctx, LOG_DEBUG, \"IPv6 Untreated protocol\");\n        break;\n      }\n    }\n  } else {\n    pcn_log(ctx, LOG_DEBUG, \"Not an IP Protocol\");\n  }\n\n  /* Here operations after the capture */\n  return RX_OK;\n}",
        "metric-configs": [
            {
                "name": "FLOW_MAP_V4",
                "map-name": "FLOW_MAP_V4",
                "extraction-options": {
                    "swap-on-read": true,
                    "empty-on-read": true
                }
            },
            {
                "name": "FLOW_MAP_V6",
                "map-name": "FLOW_MAP_V6",
                "extraction-options": {
                    "swap-on-read": true,
                    "empty-on-read": true
                }
            }
        ]
    }
}